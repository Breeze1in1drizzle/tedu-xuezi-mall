<!DOCTYPE html>
<html>
<head>
<title>DAY01</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h3>1. 项目的分析</h3>
<p>接手到新的项目，首先，应该大致分析这个项目中有哪些类型的数据，例如：商品、商品分类、用户、收货地址、收藏、购物车、订单……</p>
<p>然后，对这些需要处理的数据排个开发顺序，通常遵守的原则有2个：由简到难，由基础数据开始！所以，以上数据的开发顺序应该是：用户 &gt; 收货地址 &gt; 商品分类 &gt; 商品 &gt; 收藏 &gt; 购物车 &gt; 订单。</p>
<p>接下来，根据需求（也可以根据现有的界面设计）分析每种数据处理时涉及的功能，例如用户数据的相关功能有：注册、登录、修改密码、修改个人资料、上传头像，并对这些功能的开发设计先后顺序，通常遵守增、查、删、改的顺序，可以是：注册 &gt; 登录 &gt; 修改密码 &gt; 修改个人资料 &gt; 上传头像。</p>
<p>针对每个功能，开发顺序应该是：数据库与数据表 &gt; 实体类 &gt; 持久层 &gt; 业务层 &gt; 控制器层 &gt; 前端界面。</p>
<p><strong>做项目之前，一定要把某个数据或功能拆出来，一次只解决一个问题！</strong></p>
<h3>2. 用户-注册-数据库与数据表</h3>
<p>创建数据库：</p>
<pre><code>CREATE DATABASE tedu_store;
</code></pre>

<p>使用数据库：</p>
<pre><code>USE tedu_store;
</code></pre>

<p>创建用户数据表：</p>
<pre><code>CREATE TABLE t_user (
    uid INT AUTO_INCREMENT COMMENT '用户id',
    username VARCHAR(20) UNIQUE NOT NULL COMMENT '用户名',
    password CHAR(32) NOT NULL COMMENT '密码',
    salt CHAR(36) COMMENT '盐值',
    gender INT COMMENT '性别，0-女性，1-男性',
    phone VARCHAR(20)  COMMENT '电话',
    email VARCHAR(50) COMMENT '邮箱',
    avatar VARCHAR(50) COMMENT '头像',
    is_delete INT COMMENT '是否删除，0-未删除，1-已删除',
    created_user VARCHAR(20) COMMENT '创建执行人',
    created_time DATETIME COMMENT '创建时间',
    modified_user VARCHAR(20) COMMENT '修改执行人',
    modified_time DATETIME COMMENT '修改时间',
    PRIMARY KEY (uid)
) DEFAULT CHARSET=UTF8;
</code></pre>

<h3>3. 用户-注册-实体类</h3>
<p>打开<code>https://start.spring.io</code>，准备创建SpringBoot项目，勾选上MySQL和MyBatis，将下载的项目导入到Eclipse中，由于添加了数据库相关依赖，首先，必须在<code>application.properties</code>中添加连接数据库的配置，否则运行时会报告错误：</p>
<pre><code># datasource
spring.datasource.url=jdbc:mysql://localhost:3306/tedu_store?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>

<p>由于4个日志属性在各数据表中都将存在，对应的实体类也都需要添加这些属性，所以，先创建实体类公共的父类<code>cn.tedu.store.entity.BaseEntity</code>用于定义这4个日志属性：</p>
<pre><code>/**
 * 实体类的基类
 */
abstract class BaseEntity implements Serializable {

    private static final long serialVersionUID = -5882064199939706583L;

    private String createdUser;
    private Date createdTime;
    private String modifiedUser;
    private Date modifiedTime;

    // SET/GET/toString
}
</code></pre>

<p>由于<code>BaseEntity</code>只在当前<code>cn.tedu.store.entity</code>包中使用，且不需要单独创建对象，所以，可以将访问权限设置为默认（删除<code>public</code>），并添加<code>abstract</code>修饰符。</p>
<p>然后，创建<code>cn.tedu.store.entity.User</code>实体类：</p>
<pre><code>/**
 * 用户数据的实体类
 */
public class User extends BaseEntity {

    private static final long serialVersionUID = 8777086855777796877L;

    private Integer uid;
    private String username;
    private String password;
    private String salt;
    private Integer gender;
    private String phone;
    private String email;
    private String avatar;
    private Integer isDelete;

    // GET/SET/toString

}
</code></pre>

<h3>4. 用户-注册-持久层</h3>
<p><strong>1. 分析SQL语句</strong></p>
<p>增加数据的SQL语句：</p>
<pre><code>INSERT INTO t_user (除了uid以外的字段列表) VALUES (对应的值)
</code></pre>

<p>根据用户名查询用户数据的SQL语句：</p>
<pre><code>SELECT uid, password, salt, is_delete FROM t_user WHERE username=?
</code></pre>

<p>由于以上查询还可以应用于“登录”功能，所以，查询的字段列表中，还应该添加与“登录”相关的字段。（如果暂时无法考虑得特殊周全，可以后续再补充）</p>
<p><strong>2. 接口与抽象方法</strong></p>
<p>首先，创建持久层接口<code>cn.tedu.store.mapper.UserMapper</code>，并添加抽象方法：</p>
<pre><code>Integer insert(User user);

User findByUsername(String username);
</code></pre>

<blockquote>
<p>所有的增删改操作，返回值都使用Integer。</p>
</blockquote>
<p>由于当前是第1次编写持久层接口，还需要在启动类上添加<code>@MapeprScan(&quot;cn.tedu.store.mapper&quot;)</code>，用于指定持久层接口所在的包。</p>
<p><strong>3. 配置映射</strong></p>
<p>首先，在<code>resources</code>下创建<code>mappers</code>文件夹，然后，复制粘贴得到<code>UserMapper.xml</code>文件。</p>
<pre><code>&lt;mapper namespace=&quot;cn.tedu.store.mapper.UserMapper&quot;&gt;

    &lt;!-- 插入用户数据 --&gt;
    &lt;!-- Integer insert(User user) --&gt;
    &lt;insert id=&quot;insert&quot;&gt;
        INSERT INTO t_user (
            username, password,
            salt, gender,
            phone, email,
            avatar, is_delete,
            created_user, created_time,
            modified_user, modified_time
        ) VALUES (
            #{username}, #{password},
            #{salt}, #{gender},
            #{phone}, #{email},
            #{avatar}, #{isDelete},
            #{createdUser}, #{createdTime},
            #{modifiedUser}, #{modifiedTime}
        )
    &lt;/insert&gt;

    &lt;!-- 根据用户名查询用户数据 --&gt;
    &lt;!-- User findByUsername(String username) --&gt;
    &lt;select id=&quot;findByUsername&quot;
        resultType=&quot;cn.tedu.store.entity.User&quot;&gt;
        SELECT 
            uid, password, 
            salt, 
            is_delete AS isDelete
        FROM 
            t_user 
        WHERE 
            username=#{username}
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>

<p>由于当前是第1次配置持久层映射，则需要在<code>application.properties</code>中配置<code>mybatis.mapper-locations=classpath:mappers/*.xml</code>，用于指定映射文件所在的位置。</p>
<p>完成后，应该编写并执行单元测试：在<code>src\test\java</code>下创建<code>cn.tedu.store.mapper.UserMapperTestCase</code>类，用于测试<code>UserMapper</code>接口中定义的抽象方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTestCase {

    @Autowired
    public UserMapper mapper;

    @Test
    public void insert() {
        User user = new User();
        user.setUsername(&quot;root&quot;);
        user.setPassword(&quot;1234&quot;);
        Integer rows = mapper.insert(user);
        System.err.println(&quot;rows=&quot; + rows);
    }

    @Test
    public void findByUsername() {
        String username = &quot;root&quot;;
        User result = mapper.findByUsername(username);
        System.err.println(result);
    }

}
</code></pre>

<h3>5. 用户-注册-业务层</h3>
<p><strong>1. 设计异常</strong></p>
<p>在业务层中，应该把所有认为的操作失败（例如注册时用户名被占用、登录时用户名错误、登录时密码错误等等）设计出对应的异常！</p>
<p>则应该创建异常类：</p>
<pre><code>cn.tedu.store.service.ex.ServiceException（继承自RuntimeException）
cn.tedu.store.service.ex.UsernameDuplicateException（继承自ServiceException）
cn.tedu.store.service.ex.InsertException（继承自ServiceException）
</code></pre>

<blockquote>
<p>凡是自行抛出的异常，都应该是<code>RuntimeException</code>的子孙类异常，同时，为了便于后续的处理，应该自定义某个异常类，然后，当前项目中会抛出的异常都应该是它的子孙类异常。</p>
<p>凡涉及增删改操作都应该判断其返回值（受影响的行数），如果返回值与期望值不同，则抛出异常！</p>
</blockquote>
<p><strong>2. 接口与抽象方法</strong></p>
<p>创建<code>cn.tedu.store.service.IUserService</code>接口，并添加抽象方法：</p>
<pre><code>void reg(User user) 
    throws UsernameDuplicateException, 
        InsertException;
</code></pre>

<p>返回值：以操作正确（例如注册成功、登录成功等）为前提，如果需要向外（向方法的调用者，也就是控制器，甚至向客户端）提供某些数据，如果需要，则以这个数据的类型作为返回值，如果不需要向外提供数据，则使用<code>void</code>即可；</p>
<p>方法名称：应该与某个业务（在用户来看是某个功能）相对应，例如注册功能的方法名可以使用<code>reg</code>，登录功能的方法名称可以使用<code>login</code>；</p>
<p>参数：必须通过该参数能够调用持久层中的那些方法，以注册为例，可能需要调用持久层中的<code>Integer insert(User user)</code>和<code>User findByUsername(String username)</code>方法，则当前业务层接口中的抽象方法的参数也能基本一系列的运算能调用这2个方法。</p>
<p><strong>3. 实现</strong></p>
<p>创建<code>cn.tedu.store.service.impl.UserServiceImpl</code>类，实现<code>IUserService</code>接口，添加<code>@Service</code>注解，在类中添加<code>@Autowired private UserMapper userMapper;</code>，即：</p>
<pre><code>@Service
public class UserServiceImpl implements IUserService {

    @Autowired private UserMapper userMapper;

    @Override
    public void reg(User user) 
        throws UsernameDuplicateException, 
            InsertException {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<p>在重写抽象方法之前，应该先将持久层接口中的方法复制到业务层实现类中，添加<code>private</code>权限，并实现这些方法。</p>
<p>如果是增删改方法，则应该判断返回值，并在返回值与期望值不相符时抛出对应的异常，方法原本的返回值类型修改为<code>void</code>；如果是查询方法，则直接调用持久层对象完成查询功能即可，并不抛出异常，因为同一个查询，有时查询到数据是正确的，而有时查询不到数据才是正确的，以“根据用户名查询用户数据”为例，在“注册”功能中，只有查询结果为null才能继续注册，即查询不到数据是正确的，但是在“登录”功能中，只有查询到数据才是正确的！</p>
<pre><code>/**
 * 插入用户数据
 * @param user 用户数据
 */
private void insert(User user) {
    Integer rows = userMapper.insert(user);
    if (rows != 1) {
        throw new InsertException();
    }
}

/**
 * 根据用户名查询用户数据
 * @param username 用户名
 * @return 匹配的用户数据，如果没有匹配的数据，则返回null
 */
private User findByUsername(String username) {
    return userMapper.findByUsername(username);
}
</code></pre>

<p>然后，重写抽象方法：</p>
<pre><code>@Override
public void reg(User user) 
    throws UsernameDuplicateException, 
        InsertException {
    // 根据尝试注册的用户名查询用户数据
    String username = user.getUsername();
    User result = findByUsername(username);
    // 检查用户名是否被占用：如果查询到数据，则表示被占用，如果查询结果为null，则表示用户名没有被占用
    if (result == null) {
        // 未占用：执行注册
        insert(user);
    } else {
        // 已占用：抛出UsernameDuplicateException
        throw new UsernameDuplicateException();
    }
}
</code></pre>

<p>可以看到，重写的方法中，并不直接调用持久层对象来实现增删改查，而是调用自身的私有方法，间接的调用到持久层对象来实现数据访问。</p>
<p>完成后，应该编写并执行单元测试：在<code>src\test\java</code>下创建<code>cn.tedu.store.service.UserServiceTestCase</code>类，用于测试<code>IUserService</code>接口中定义的抽象方法：</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class UserServiceTestCase {

    @Autowired
    public IUserService service;

    @Test
    public void reg() {
        try {
            User user = new User();
            user.setUsername(&quot;mybatis&quot;);
            user.setPassword(&quot;1234&quot;);
            user.setGender(1);
            user.setPhone(&quot;13800138006&quot;);
            user.setEmail(&quot;mybatis@tedu.cn&quot;);
            user.setAvatar(&quot;http://www.tedu.cn/mybatis.png&quot;);
            service.reg(user);
            System.err.println(&quot;OK&quot;);
        } catch (ServiceException e) {
            System.err.println(e.getClass().getName());
            System.err.println(e.getMessage());
        }
    }

}
</code></pre>

<p>注册后，通过查询数据表，可以发现，仍有一部分数据没有值，例如is<em>delete、created</em>user字段等，所以，业务层的实现类还有一项任务，就是“保障数据的完整性”，那些不由用户（客户端）提交的数据，应该在业务层中来生成，所以，需要调整业务层实现类中的代码：</p>
<pre><code>@Override
public void reg(User user) 
    throws UsernameDuplicateException, 
        InsertException {
    // 根据尝试注册的用户名查询用户数据
    String username = user.getUsername();
    User result = findByUsername(username);
    // 检查用户名是否被占用：如果查询到数据，则表示被占用，如果查询结果为null，则表示用户名没有被占用
    if (result == null) {
        // 设置is_delete
        user.setIsDelete(0);

        // 设置4项日志
        Date now = new Date();
        user.setCreatedUser(username);
        user.setCreatedTime(now);
        user.setModifiedUser(username);
        user.setModifiedTime(now);

        // TODO 密码加密

        // 执行注册
        insert(user);
    } else {
        // 已占用：抛出UsernameDuplicateException
        throw new UsernameDuplicateException(
            &quot;注册失败！您尝试注册的用户名(&quot; + username + &quot;)已经被占用！&quot;);
    }
}
</code></pre>

<h3>6. 用户-注册-控制器层</h3>
<h3>7. 用户-注册-前端界面</h3>
<h3>【附】 常见错误</h3>
<p>【错误描述】 Caused by: com.mysql.cj.exceptions.WrongArgumentException: No timezone mapping entry for 'Asia/Shanghaispring.datasource.username'</p>
<p>【错误原因】 数据库连接字符串有误</p>
<p>【错误描述】 Caused by: java.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)</p>
<p>【错误原因】 数据库密码错误</p>
<p>【错误描述】 NoSuchBeanDefinitionException ... 'cn.tedu.store.mapper.UserMapper' ... expected at least 1 bean ...</p>
<p>【错误原因】 没有找到UserMapper类型的对象，可能是因为在启动类（StoreApplication）上没有添加<code>@MapperScanner</code>注解，或注解中填写的包名是错误的，</p>
<p>【错误描述】 java.lang.NullPointerException at cn.tedu.store.mapper.UserMapperTestCase.findByUsername(UserMapperTestCase.java:29)</p>
<p>【错误原因】 所有的<code>NullPointerException</code>都是因为某个为null的值调用了属性或方法，应该根据下一行错误提示找到对应的代码，例如<code>User result = mapper.findByUsername(username);</code>，在这一行代码中，找到<code>.</code>左侧的对象，极有可能它是null值！如果一行代码中有多个<code>.</code>，则每个<code>.</code>的左侧都有可能是<code>null</code>值，甚至在某个方法的调用中，参数为null也会导致<code>NullPointerException</code>。如果某个值应该是自动装配的，则检查它有没有添加<code>@Autowired</code>注解，或它所在的类是否被Spring所管理。</p>
<p>【错误描述】 BadSqlGrammarException</p>
<p>【错误原因】 尝试执行的SQL语句存在语法错误，可以通过进一步的提示找出错误，如果进一步的提示中包含<code>near</code>关键字，则找<code>near</code>提示的代码的左侧的SQL语句部分，也可以直接去检查SQL语句</p>
<p>【错误描述】 There is no getter for property named ...</p>
<p>【错误原因】 在配置映射时，应该填写类中的属性名时，所填写的名称在类中并不存在</p>
<h3>【附】关于配置MyBatis映射没有代码提示的解决方案</h3>
<p>先连接达内公司内网，下载：http://schema.tedu.cn/proxy/dtd/ibatis-3-mapper.dtd</p>
<p>下载的文件存储到任意位置均可。</p>
<p>在Eclipse中打开设置，左侧选择XML &gt; XML Catelog，并在右侧点击Add按钮：</p>
<p><img src="MYBATIS-DTD-01.png" /></p>
<p>然后，在左侧选择第1项，右侧选择到刚才下载的文件，然后在Key这一栏输入<code>-//ibatis.apache.org//DTD Mapper 3.0//EN</code>（在映射文件顶部<code>Public</code>字样右侧的字符串）：</p>
<p><img src="MYBATIS-DTD-02.png" /></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
